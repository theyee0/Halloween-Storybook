;;;; parser.lisp

(in-package #:parser)

(defparameter +precedences+
  '((:inc . 8)
    (:dec . 8)
    (:times . 7)
    (:divide . 7)
    (:mod . 7)
    (:plus . 6)
    (:minus . 6)
    (:max . 5)
    (:min. 5)
    (:random . 4)
    (:equal . 3)
    (:not-equal . 3)
    (:geq-to . 3)
    (:leq-to . 3)
    (:less-than . 3)
    (:greater-than . 3)
    (:and . 2)
    (:or . 2)
    (:not . 2))
  "Order of precedence of operations, in-line with PEMDAS and
somewhat in line with the expectations of C-based languages")

(defparameter +functions+
  '((:inc . 1+)
    (:dec . 1-)
    (:times . *)
    (:divide . /)
    (:mod . mod)
    (:plus . +)
    (:minus . -)
    (:max . max)
    (:min. min)
    (:random . random)
    (:equal . =)
    (:not-equal . /=)
    (:geq-to . >=)
    (:leq-to . <=)
    (:less-than . <)
    (:greater-than . >)
    (:and . and)
    (:or . or)
    (:not . not)))

(defparameter +arity+
  '((:inc . 1)
    (:dec . 1)
    (:times . 2)
    (:divide . 2)
    (:mod . 2)
    (:plus . 2)
    (:minus . 2)
    (:max . 2)
    (:min. 2)
    (:random . 1)
    (:equal . 2)
    (:not-equal . 2)
    (:geq-to . 2)
    (:leq-to . 2)
    (:less-than . 2)
    (:greater-than . 2)
    (:and . 2)
    (:or . 2)
    (:not . 1)))

(defun strip-spaces (line)
  (coerce (mapcan (lambda (x) (and (not (char= x #\Space)) (list x)))
                  (coerce line 'list))
          'string))

(defun get-literal (lexeme)
  (cond
    ((every (lambda (x) (or (digit-char-p x) (char= x #\-))) lexeme) (parse-integer lexeme))
    ((every (lambda (x) (or (alpha-char-p x) (char= x #\Space))) lexeme) (intern (strip-spaces lexeme)))
    (T nil)))

(defun split-list (list separator)
  (labels ((split-aux (list current-list separator)
             (cond
               ((null list) (and current-list (list (nreverse current-list))))
               ((eq (caar list) separator) (cons (nreverse current-list) (split-aux (cdr list) (list) separator)))
               (t (split-aux (cdr list) (cons (car list) current-list) separator)))))
    (split-aux list (list) separator)))

(defun parse-function (lines)
  (let* ((current-line (car lines))
         (name (cdadr current-line))
         (components (split-list current-line :then))
         (parameters (cadr (split-list (car components) :with)))
         (parameter-list (split-list parameters :also)))
    (pop lines)
    (values (nconc (list 'defun (intern (strip-spaces name)) (map 'list (lambda (x) (get-literal (cdar x))) parameter-list))
                   (loop :while (not (eq (caaar lines) :block-end))
                         :collect (multiple-value-bind (expression next-line) (parse-line lines)
                                    (setf lines next-line)
                                    expression)))
            (cdr lines))))

(defun parse-funcall (lines)
  (print lines)
  (let* ((current-line (car lines))
         (name (cdadr current-line))
         (parameters (split-list (cadr (split-list current-line :with)) :also)))
    (values (cons (get-literal name)
                  (map 'list #'parse-expression parameters))
            (cdr lines))))

(defun parse-defvar (lines)
  (values (list 'defvar (parse-expression (cdar lines)))
          (cdr lines)))

(defun get-precedence (operator)
  (cdr (assoc operator +precedences+)))

(defun eval-rpn-stack (list)
  (when (null (assoc (car list) +functions+))
    (return-from eval-rpn-stack (values (car list)
                                        (cdr list))))
  (let ((current-operation (cdr (assoc (car list) +functions+)))
        (current-arity (cdr (assoc (car list) +arity+)))
        (subexprs nil))
    (pop list)
    (values (nconc (list current-operation)
                   (dotimes (iteration current-arity subexprs)
                     (multiple-value-bind (operation remaining-list) (eval-rpn-stack list)
                       (setf list remaining-list)
                       (setf subexprs (cons operation subexprs)))))
            list)))

(defun parse-expression (expr-list)
  (let ((operators (list))
        (output (list)))
    (loop :for expr :in expr-list
          :do
             (cond
               ((eq (car expr) :true) (push t output))
               ((eq (car expr) :nil) (push nil output))
               ((eq (car expr) :literal) (push (get-literal (cdr expr)) output))
               ((eq (car expr) :string) (push (cdr expr) output))
               (t (let ((precedence (get-precedence (car expr))))
                    (when (null precedence)
                      (return-from parse-expression (values :parse-error :parse-error)))
                    (loop :while (and operators
                                      (>= (get-precedence (car operators)) precedence))
                          :do
                             (push (car operators) output)
                             (pop operators))
                    (push (car expr) operators)))))
    (setf output (nconc operators output))
    (eval-rpn-stack output)))

(defun parse-if (lines)
  (let* ((current-word (cdar lines))
         (condition (loop :while (not (eq (caar current-word) :then))
                          :collect (car current-word)
                          :do (pop current-word)))
         (then-block (and (pop current-word) (loop :while (and current-word (not (eq (caar current-word) :else)))
                                                   :collect (car current-word)
                                                   :do (pop current-word))))
         (else-block (and (pop current-word) (loop :while current-word
                                                   :collect (car current-word)
                                                   :do (pop current-word)))))
    (values (list 'if (parse-expression condition) (parse-line (list then-block)) (parse-line (list else-block)))
            (cdr lines))))

(defun parse-when (lines)
  (let* ((current-line (car lines))
         (current-word (cdr current-line))
         (condition (loop :while (not (eq (car current-word) :then))
                          :do (setf current-word (cdr current-word))
                          :collect (car current-word)))
         (then-block (loop :while current-word
                           :do (setf current-word (cdr current-word))
                           :collect (car current-word))))
    (values (nconc (list 'when (parse-expression condition)
                         (parse-expression then-block)))
            (cdr lines))))

(defun parse-print (lines)
  (let* ((current-line (car lines))
         (components (split-list current-line :with))
         (destination (cdar components))
         (parameters (cadr components))
         (parameter-list (split-list parameters :also)))
    (values (nconc (list 'format
                         (parse-expression destination)
                         (parse-expression (car parameter-list)))
                   (map 'list
                        #'parse-expression
                        (cdr parameter-list)))
            (cdr lines))))

(defun parse-while (lines)
  "Parse an expression of the form :while [condition]... :then [operations]..."
  (let* ((current-line (split-list (car lines) :then))
         (condition (cdar current-line))
         (operations (cdr current-line)))
    (values (list 'loop :while (parse-expression condition) :do (parse-line operations))
            (cdr lines))))

(defun parse-string (line)
  (let* ((literal (cadr line))
         (string (cdr literal)))
    (values string (cddr line))))

(defun parse-set (lines)
  (let* ((current-line (car lines)))
    (values (list 'setf
                  (get-literal (cdadr current-line))
                  (parse-line (list (cdddr current-line))))
            (cdr lines))))

(defun parse-let (lines)
  (let* ((current-line (car lines))
         (bindings (map 'list (lambda (x) (list (parse-expression (car x)) (parse-expression (cadr x))))
                        (map 'list (lambda (x) (split-list x :as)) (split-list (cdr current-line) :also)))))
    (setf lines (cdr lines))
    (values (nconc (list 'let bindings)
                   (loop :while (not (eq (caaar lines) :block-end))
                         :collect (setf lines (parse-line lines))))
            (cdr lines))))

(defun parse-readline (lines)
  (values (list 'read-line)
          (cdr lines)))

(defun parse-random (lines)
  (values (list 'random (parse-line (list (cdar lines))))
          (cdr lines)))

(defun parse-line (lines)
  (case (caaar lines)
    (:defun (parse-function lines))
    (:defvar (parse-defvar lines))
    (:funcall (parse-funcall lines))
    (:while (parse-while lines))
    (:if (parse-if lines))
    (:random (parse-random lines))
    (:when (parse-when lines))
    (:print (parse-print lines))
    (:read-line (parse-readline lines))
    (:set (parse-set lines))
    (:let (parse-let lines))
    (otherwise (values (parse-expression (car lines))
                       (cdr lines)))))

(defun parse-lines (lines)
  (loop :while lines
        :collect (multiple-value-bind (value remaining-lines) (parse-line lines)
                   (setf lines remaining-lines)
                   (if (eq value :parse-error)
                       (progn
                         (format t "Error parsing reached")
                         (return-from parse-lines))
                       value))))
